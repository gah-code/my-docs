Alright — shipping a minimal-but-working **Add Note 2.0**, **Graph View (Dash + Cytoscape)**, and **Quip integration**. I’m keeping it small, Python-first, filesystem-first, and ready to extend. Two apps:

* `app.py` → Flask UI for Add Note 2.0 (+ Quip search, thread HTML paging, summarize+insert, folder browse) and atomic persistence.
* `graph_app.py` → Dash + Cytoscape graph with degree-based sizing + 1-hop highlighting (reads `data/graph/graph.json`).

I’ve inlined the HTML/JS for speed and to keep it MVP. If `QUIP_TOKEN` is missing, the Quip client returns mock data so the UI still works end-to-end.

---

### 1) `app.py` — Flask UI + FS store + Quip client (mock-aware) + minimal index/graph

```python
# app.py
# NotaLink - Add Note 2.0 MVP with Quip lookup + filesystem-first persistence.
# Run:  python app.py
# Env:  QUIP_TOKEN (optional), DATA_DIR=./data (default), DEBUG=1 (optional)

from __future__ import annotations
import os, json, time, uuid, re, shutil, tempfile, pathlib, hashlib
from datetime import datetime, timezone
from typing import Any, Dict, List, Tuple
from flask import Flask, request, jsonify, render_template_string
import threading

try:
    import requests
except Exception:
    requests = None  # Works in mock mode without requests.

DATA_DIR = pathlib.Path(os.getenv("DATA_DIR", "./data")).resolve()
SUBDIRS = ["notes", "links", "index", "graph", "lookup_cache", "_wal"]
for s in SUBDIRS:
    (DATA_DIR / s).mkdir(parents=True, exist_ok=True)

app = Flask(__name__)
app.config["JSON_SORT_KEYS"] = False

# -----------------------------
# Utilities: time/id/json/atomic
# -----------------------------
def now_iso() -> str:
    return datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")

def new_id() -> str:
    return uuid.uuid4().hex[:12]  # short, ok for MVP

def _wal_write(entry: Dict[str, Any]):
    wal_path = DATA_DIR / "_wal" / f"{datetime.utcnow().strftime('%Y-%m-%dT%H-%M-%SZ')}_{new_id()}.json"
    tmp = wal_path.with_suffix(".tmp")
    with open(tmp, "w", encoding="utf-8") as f:
        json.dump(entry, f, ensure_ascii=False, indent=2)
        f.flush(); os.fsync(f.fileno())
    os.replace(tmp, wal_path)

def atomic_write_json(rel_path: pathlib.Path, obj: Dict[str, Any]):
    out_path = DATA_DIR / rel_path
    out_path.parent.mkdir(parents=True, exist_ok=True)
    tmp = out_path.with_suffix(".tmp")
    pre = {"evt":"pre_write", "path":str(out_path), "ts": now_iso()}
    _wal_write(pre)
    with open(tmp, "w", encoding="utf-8") as f:
        json.dump(obj, f, ensure_ascii=False, indent=2)
        f.flush(); os.fsync(f.fileno())
    os.replace(tmp, out_path)
    post = {"evt":"post_write", "path":str(out_path), "ts": now_iso()}
    _wal_write(post)

# -----------------------------
# Minimal inverted index & graph
# -----------------------------
TOKEN_RE = re.compile(r"[A-Za-z0-9]{3,}")

def tokenize(text: str) -> List[str]:
    return [t.lower() for t in TOKEN_RE.findall(text)]

def rebuild_index():
    inv = {}
    notes_dir = DATA_DIR / "notes"
    for p in notes_dir.glob("*.json"):
        try:
            note = json.loads(p.read_text(encoding="utf-8"))
            terms = set(tokenize(f"{note.get('title','')} {note.get('content','')}"))
            for t in terms:
                inv.setdefault(t, []).append(note["id"])
        except Exception:
            continue
    # Write JSONL
    idx_path = DATA_DIR / "index" / "inverted.jsonl"
    tmp = idx_path.with_suffix(".tmp")
    with open(tmp, "w", encoding="utf-8") as f:
        for term, ids in sorted(inv.items()):
            line = json.dumps({"term": term, "note_ids": sorted(set(ids))}, ensure_ascii=False)
            f.write(line + "\n")
        f.flush(); os.fsync(f.fileno())
    os.replace(tmp, idx_path)

def compute_graph():
    """Compute nodes/edges from notes + links; degree-based sizing."""
    notes = {}
    for p in (DATA_DIR / "notes").glob("*.json"):
        try:
            obj = json.loads(p.read_text(encoding="utf-8"))
            notes[obj["id"]] = obj
        except Exception:
            pass
    edges = []
    for p in (DATA_DIR / "links").glob("*.json"):
        try:
            obj = json.loads(p.read_text(encoding="utf-8"))
            edges.append((obj["src"], obj["dst"]))
        except Exception:
            pass
    degree = {nid: 0 for nid in notes}
    for s, d in edges:
        if s in degree: degree[s] += 1
        if d in degree: degree[d] += 1
    nodes = []
    for nid, note in notes.items():
        size = 20 + min(40, degree.get(nid, 0) * 5)  # base 20 + 5*degree (cap)
        nodes.append({"data": {"id": nid, "label": note.get("title","(untitled)"), "degree": degree.get(nid,0), "size": size}})
    cy_edges = []
    for s, d in edges:
        if s in notes and d in notes:
            cy_edges.append({"data": {"id": f"{s}-{d}", "source": s, "target": d}})
    graph = {"nodes": nodes, "edges": cy_edges, "generated_at": now_iso()}
    atomic_write_json(pathlib.Path("graph/graph.json"), graph)

# -----------------------------
# Quip client (real or mock)
# -----------------------------
class QuipClient:
    def __init__(self, token: str | None):
        self.token = token
        self.base = "https://platform.quip.com/1"  # common base for legacy API; adjust if needed
        self._mock = not token or not requests

    def _auth(self, headers: Dict[str,str]|None=None) -> Dict[str,str]:
        h = {"Content-Type":"application/json"}
        if self.token:
            h["Authorization"] = f"Bearer {self.token}"
        if headers: h.update(headers)
        return h

    # --- Search ---
    def search(self, query: str, count: int = 8, only_titles: bool=False, filters: List[str]|None=None) -> List[Dict[str,Any]]:
        if self._mock:
            # Return stable mock hits
            hits = [
                {"id":"qdoc_abc123", "type":"doc", "title":"ZK: Atomic Notes", "path":"Team/PKM", "snippet":"Atomic = one idea per note.", "url":"quip://thread/qdoc_abc123"},
                {"id":"qchat_42", "type":"chat", "title":"Eng Sync 2025-08-20", "path":"Chats/Core", "snippet":"Action: link graph view to...", "url":"quip://thread/qchat_42"},
                {"id":"qfold_xyz", "type":"folder", "title":"Research/Zettelkasten", "path":"Company/Research", "snippet":None, "url":"quip://folder/qfold_xyz"},
            ]
            return hits[:count]
        # Real call (best-effort; adjust to your endpoint shape)
        try:
            params = {"query": query, "count": count}
            # Some Quip deployments use /search/threads or /search
            resp = requests.get(f"{self.base}/search/threads", params=params, headers=self._auth(), timeout=15)
            resp.raise_for_status()
            data = resp.json()
            results = []
            for it in data.get("items", []):
                results.append({
                    "id": it.get("id") or it.get("thread_id") or it.get("folder_id",""),
                    "type": it.get("type","thread"),
                    "title": it.get("title",""),
                    "path": it.get("path",""),
                    "snippet": it.get("snippet"),
                    "url": f"quip://thread/{it.get('id')}" if it.get("id") else ""
                })
            return results
        except Exception as e:
            # Fallback mock on error
            return self.search(query, count, only_titles, filters=None)

    # --- Thread HTML (paged) ---
    def thread_html(self, thread_id: str, cursor: str|None=None, limit: int=1) -> Dict[str, Any]:
        if self._mock:
            page = {"html": f"<h3>Thread {thread_id}</h3><p>Lorem ipsum summary seed for {thread_id}…</p>",
                    "next_cursor": None}
            return page
        try:
            params = {"thread_id": thread_id, "cursor": cursor, "limit": limit}
            # Some Quip installations provide HTML via /threads/read or /messages
            resp = requests.get(f"{self.base}/threads/read", params=params, headers=self._auth(), timeout=20)
            resp.raise_for_status()
            js = resp.json()
            # Map to a generic shape
            html = js.get("html") or js.get("content_html") or ""
            next_cur = js.get("next_cursor")
            return {"html": html, "next_cursor": next_cur}
        except Exception:
            return self.thread_html(thread_id, None, limit=limit)

    # --- Folder listing/browse ---
    def folder(self, folder_id: str) -> Dict[str, Any]:
        if self._mock:
            return {"id": folder_id, "title":"Research/Zettelkasten", "children":[
                {"id":"qdoc_child1", "type":"doc", "title":"How to Write a Note"},
                {"id":"qdoc_child2", "type":"doc", "title":"Structure Notes Primer"},
            ]}
        if requests is None:
            return {"id": folder_id, "title":"(no-requests)", "children":[]}
        try:
            resp = requests.get(f"{self.base}/folders/{folder_id}", headers=self._auth(), timeout=15)
            resp.raise_for_status()
            return resp.json()
        except Exception:
            return {"id": folder_id, "title":"(error)", "children":[]}

QUIP = QuipClient(os.getenv("QUIP_TOKEN"))

# -----------------------------
# Minimal "summarizer" (LLM slot)
# -----------------------------
def summarize_html_to_bullets(html: str, max_points: int = 5) -> str:
    """Placeholder: extract plain text, pick first few sentences as bullets."""
    txt = re.sub("<[^>]+>", " ", html)
    sents = [s.strip() for s in re.split(r"[.\n]", txt) if s.strip()]
    picks = sents[:max_points]
    bullets = "\n".join([f"- {s}" for s in picks])
    return bullets or "- (no content)"

# -----------------------------
# REST: Quip
# -----------------------------
@app.get("/api/quip/search")
def api_quip_search():
    q = request.args.get("query","").strip()
    if len(q) < 3:
        return jsonify({"results":[]})
    count = int(request.args.get("count","8") or 8)
    only_titles = request.args.get("only_titles","false").lower() == "true"
    filters = request.args.get("filters","")
    filters = [x for x in filters.split(",") if x] if filters else []
    # Cache by hash(query+filters+count+only_titles) for 10m
    cache_key = hashlib.sha1(f"{q}|{count}|{only_titles}|{','.join(filters)}".encode()).hexdigest()
    cache_path = DATA_DIR / "lookup_cache" / f"{cache_key}.json"
    if cache_path.exists():
        try:
            js = json.loads(cache_path.read_text(encoding="utf-8"))
            if (time.time() - js.get("ts",0)) < 600:
                return jsonify({"results": js.get("results",[])})
        except Exception:
            pass
    results = QUIP.search(q, count=count, only_titles=only_titles, filters=filters)
    atomic_write_json(pathlib.Path(f"lookup_cache/{cache_key}.json"), {"ts": time.time(), "results": results})
    return jsonify({"results": results})

@app.get("/api/quip/thread_html")
def api_quip_thread_html():
    tid = request.args.get("id","")
    cursor = request.args.get("cursor")
    limit = int(request.args.get("limit","1") or 1)
    page = QUIP.thread_html(tid, cursor=cursor, limit=limit)
    return jsonify(page)

@app.get("/api/quip/folder")
def api_quip_folder():
    fid = request.args.get("id","")
    if not fid:
        return jsonify({"error":"missing id"}), 400
    return jsonify(QUIP.folder(fid))

@app.post("/api/quip/summarize")
def api_quip_summarize():
    data = request.get_json(force=True) or {}
    html = data.get("html","")
    bullets = summarize_html_to_bullets(html, max_points=5)
    return jsonify({"summary_md": bullets})

# -----------------------------
# REST: Notes & Links
# -----------------------------
@app.post("/api/notes")
def api_notes_create():
    data = request.get_json(force=True) or {}
    title = data.get("title","").strip()
    ntype = data.get("type","fleeting")
    content = data.get("content","")
    citations = data.get("citations", [])
    provenance = data.get("provenance", [])
    dry_run = bool(data.get("dry_run", True))

    note_id = new_id()
    note = {
        "id": note_id,
        "title": title or "(untitled)",
        "type": ntype,
        "content": content,
        "citations": citations,
        "provenance": provenance,
        "created_at": now_iso(),
        "updated_at": now_iso(),
        "meta": {}
    }
    diff = {"would_write": f"notes/{note_id}.json", "bytes": len(json.dumps(note))}
    if dry_run:
        return jsonify({"note": None, "diff": diff, "dry_run": True})

    atomic_write_json(pathlib.Path(f"notes/{note_id}.json"), note)
    # Index + graph compute in background so UI is snappy
    threading.Thread(target=rebuild_index, daemon=True).start()
    threading.Thread(target=compute_graph, daemon=True).start()
    return jsonify({"note": note, "diff": {}, "dry_run": False})

@app.post("/api/links/create")
def api_links_create():
    data = request.get_json(force=True) or {}
    src = data.get("src_id"); dst = data.get("dst_id")
    rationale = data.get("rationale","")
    provenance = data.get("provenance", [])
    dry_run = bool(data.get("dry_run", True))
    if not src or not dst:
        return jsonify({"error":"src_id and dst_id required"}), 400
    link_id = new_id()
    link = {"id": link_id, "src": src, "dst": dst, "rationale": rationale, "provenance": provenance, "created_at": now_iso()}
    diff = {"would_write": f"links/{link_id}.json"}
    if dry_run:
        return jsonify({"link": None, "diff": diff, "dry_run": True})
    atomic_write_json(pathlib.Path(f"links/{link_id}.json"), link)
    threading.Thread(target=compute_graph, daemon=True).start()
    return jsonify({"link": link, "dry_run": False})

@app.post("/api/links/suggest")
def api_links_suggest():
    """Very naive lexical suggestions: overlap ≥ 6 unique terms."""
    data = request.get_json(force=True) or {}
    note_text = f"{data.get('title','')} {data.get('content','')}"
    terms = set(tokenize(note_text))
    # Load other notes
    hits = []
    for p in (DATA_DIR / "notes").glob("*.json"):
        obj = json.loads(p.read_text(encoding="utf-8"))
        if obj.get("id") == data.get("id"):  # skip self
            continue
        oterms = set(tokenize(f"{obj.get('title','')} {obj.get('content','')}"))
        overlap = terms.intersection(oterms)
        if len(overlap) >= 6:
            hits.append({"candidate_id": obj["id"], "title": obj.get("title",""), "rationale": f"{len(overlap)} shared terms", "confidence": min(0.99, 0.05*len(overlap))})
    return jsonify({"suggestions": hits[:8]})

# -----------------------------
# UI: Add Note 2.0 (inline HTML)
# -----------------------------
PAGE = """
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>NotaLink – Add Note 2.0</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    body { font-family: ui-sans-serif, system-ui, -apple-system; margin: 24px auto; max-width: 960px; color: #0f172a; }
    h1 { font-size: 28px; margin: 0 0 8px; }
    .micro { color:#475569; margin-bottom:16px;}
    .row { display:flex; gap:12px; align-items:center; flex-wrap: wrap; }
    input[type=text], textarea { width: 100%; padding: 12px 14px; border-radius: 10px; border: 1px solid #cbd5e1; outline: none; }
    input[type=text]:focus, textarea:focus { box-shadow: 0 0 0 3px #93c5fd; border-color:#60a5fa; }
    .seg { display:inline-flex; border:1px solid #cbd5e1; border-radius: 10px; overflow:hidden; }
    .seg button { padding:8px 12px; border:none; background:#f8fafc; cursor:pointer;}
    .seg button.active { background:#e0f2fe; }
    .field { margin-bottom:16px;}
    .popover { position:absolute; z-index:20; background:white; border:1px solid #e2e8f0; border-radius: 10px; padding:8px; width: 100%; max-width: 720px; box-shadow: 0 8px 30px rgba(0,0,0,.08); }
    .result { padding:8px; border-radius:8px; display:flex; justify-content:space-between; gap:12px; }
    .result:hover { background:#f8fafc; }
    .actions button { margin-left:8px; }
    .kbd { font: 12px/1.4 ui-monospace,SFMono-Regular,Menlo,monospace; background:#e2e8f0; padding:2px 6px; border-radius:6px;}
    .controls { display:flex; gap:10px; align-items:center; flex-wrap: wrap; }
    .chip { font-size:12px; padding:4px 8px; border:1px solid #cbd5e1; border-radius:999px; background:#f8fafc; cursor:pointer;}
    .chip.active { background:#dbeafe; border-color:#93c5fd;}
    .btn { border:none; border-radius:10px; padding:10px 14px; cursor:pointer; }
    .btn.primary { background:#2563eb; color:white; }
    .btn.secondary { background:#e2e8f0; }
    .muted { color:#64748b; }
    .two { display:grid; grid-template-columns: 1fr 1fr; gap: 12px; }
  </style>
</head>
<body>
  <h1>Add Note 2.0</h1>
  <div class="micro">Filesystem-first • Atomic writes • Dry-run by default</div>

  <div class="field">
    <label>Title</label>
    <input id="title" type="text" placeholder="Short, explicit summary title"/>
  </div>

  <div class="field">
    <label>Note type</label><br/>
    <div class="seg" id="typeSeg">
      <button data-type="fleeting" class="active">Fleeting</button>
      <button data-type="literature">Literature</button>
      <button data-type="permanent">Permanent</button>
    </div>
  </div>

  <div class="field" style="position:relative;">
    <label>Knowledge lookup (Quip)</label>
    <div class="controls">
      <input id="lookup" type="text" placeholder="Type ≥ 3 chars to search Quip…  ( / to focus )" />
      <span class="chip" data-filter="docs">Docs</span>
      <span class="chip" data-filter="chats">Chats</span>
      <span class="chip" data-filter="folders">Folders</span>
      <label class="chip"><input id="onlyTitles" type="checkbox"/> Only titles</label>
      <label class="chip">Count <input id="count" type="number" min="1" max="25" value="8" style="width:54px;"/></label>
    </div>
    <div id="popover" class="popover" style="display:none;"></div>
  </div>

  <div class="field">
    <label>Content (Markdown supported)</label>
    <textarea id="content" rows="12" placeholder="Paste or write. Use Insert cite / Summarize+Insert from lookup."></textarea>
  </div>

  <div class="two">
    <label><input id="dryRun" type="checkbox" checked/> Dry run (no write)</label>
    <div class="muted">Shortcuts: <span class="kbd">Ctrl/⌘+Enter</span> Save + Suggest, <span class="kbd">Ctrl/⌘+S</span> Save</div>
  </div>

  <div style="margin-top:12px; display:flex; gap:12px;">
    <button id="saveSuggest" class="btn primary">Save + suggest links</button>
    <button id="save" class="btn secondary">Save note</button>
    <a class="btn secondary" href="/__graph_hint" target="_blank">Open Graph View</a>
  </div>

  <div id="out" class="field" style="margin-top:16px;"></div>

<script>
const $ = (sel)=>document.querySelector(sel);
const $$ = (sel)=>Array.from(document.querySelectorAll(sel));
let noteType = "fleeting";
let filters = new Set(["docs","chats","folders"]);
let citations = [];   // {id,url,title,at}
let provenance = [];  // ["quip://..."]
let pendingLinks = []; // {dst_id, rationale, provenance}

$("#typeSeg").addEventListener("click",(e)=>{
  if(e.target.tagName !== "BUTTON") return;
  $$("#typeSeg button").forEach(b=>b.classList.remove("active"));
  e.target.classList.add("active");
  noteType = e.target.dataset.type;
})

$$(".chip[data-filter]").forEach(ch=>{
  ch.classList.add("active");
  ch.addEventListener("click", ()=>{
    const k = ch.dataset.filter;
    if(filters.has(k)){ filters.delete(k); ch.classList.remove("active"); }
    else { filters.add(k); ch.classList.add("active"); }
    doSearch();
  })
});

$("#lookup").addEventListener("keydown",(e)=>{
  if(e.key === "/"){ e.preventDefault(); $("#lookup").focus(); }
});

let tmr = null;
$("#lookup").addEventListener("input", ()=>{
  clearTimeout(tmr);
  tmr = setTimeout(doSearch, 250);
});

async function doSearch(){
  const q = $("#lookup").value.trim();
  if(q.length < 3){ $("#popover").style.display = "none"; return; }
  const params = new URLSearchParams({
    query: q,
    count: String(parseInt($("#count").value||"8")),
    only_titles: $("#onlyTitles").checked ? "true":"false",
    filters: Array.from(filters).join(",")
  });
  const r = await fetch("/api/quip/search?"+params.toString());
  const js = await r.json();
  renderResults(js.results||[]);
}
function renderResults(items){
  const pop = $("#popover");
  if(!items.length){ pop.style.display="none"; return; }
  pop.innerHTML = items.map(it=>`
    <div class="result">
      <div>
        <div><strong>${escapeHtml(it.title||"")}</strong> <span class="muted">(${it.type})</span></div>
        <div class="muted">${escapeHtml(it.path||"")} ${it.snippet?("— "+escapeHtml(it.snippet)):""}</div>
      </div>
      <div class="actions">
        ${it.type!=="folder" ? `<button onclick='insertCite(${json(it)})'>Insert cite</button>`:""}
        ${it.type!=="folder" ? `<button onclick='linkThread(${json(it)})'>Link thread</button>`:""}
        ${it.type!=="folder" ? `<button onclick='summarizeInsert(${json(it)})'>Summarize + Insert</button>`:""}
        ${it.type==="folder" ? `<button onclick='browseFolder(${json(it)})'>Browse</button>`:""}
      </div>
    </div>
  `).join("");
  pop.style.display = "block";
}
function json(o){ return JSON.stringify(o).replace(/'/g,"&#39;"); }
function escapeHtml(s){ return (s||"").replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[m])); }

function insertCite(it){
  const md = `[${it.title||it.id}](${it.url||("quip://thread/"+it.id)})`;
  $("#content").value += ( $("#content").value.endsWith("\n") ? "" : "\n") + md + "\n";
  citations.push({id: it.id, url: it.url||("quip://thread/"+it.id), title: it.title||"", at: new Date().toISOString()});
  provenance.push(it.url||("quip://thread/"+it.id));
  toast("Inserted citation.");
}
function linkThread(it){
  pendingLinks.push({dst_id: it.id, rationale: "Related via lookup", provenance:[it.url||("quip://thread/"+it.id)]});
  toast("Queued link to create after save.");
}
async function summarizeInsert(it){
  const page = await fetch(`/api/quip/thread_html?id=${encodeURIComponent(it.id)}&limit=1`).then(r=>r.json());
  const html = page.html || "";
  const sum = await fetch("/api/quip/summarize",{method:"POST", headers:{"Content-Type":"application/json"}, body: JSON.stringify({html})}).then(r=>r.json());
  const block = `> ${sum.summary_md}\n\n[Source: ${it.title||it.id}](${it.url||("quip://thread/"+it.id)})\n`;
  $("#content").value += ( $("#content").value.endsWith("\n") ? "" : "\n") + block + "\n";
  citations.push({id: it.id, url: it.url||("quip://thread/"+it.id), title: it.title||"", at: new Date().toISOString()});
  provenance.push(it.url||("quip://thread/"+it.id));
  toast("Summary inserted.");
}
async function browseFolder(it){
  const js = await fetch(`/api/quip/folder?id=${encodeURIComponent(it.id)}`).then(r=>r.json());
  const kids = (js.children||[]).map(k=>`• ${escapeHtml(k.title)} (${k.type})`).join("\\n");
  toast("Folder:\\n"+ kids);
}

async function saveNote(saveAndSuggest=false){
  const payload = {
    title: $("#title").value.trim(),
    type: noteType,
    content: $("#content").value,
    citations, provenance,
    dry_run: $("#dryRun").checked
  };
  const res = await fetch("/api/notes",{method:"POST", headers:{"Content-Type":"application/json"}, body: JSON.stringify(payload)});
  const js = await res.json();
  if(js.dry_run){
    $("#out").innerText = "Dry run OK: " + JSON.stringify(js.diff,null,2);
    return;
  }
  $("#out").innerText = "Saved note: " + js.note.id;
  // create queued links
  for(const L of pendingLinks){
    await fetch("/api/links/create",{method:"POST", headers:{"Content-Type":"application/json"}, body: JSON.stringify({src_id: js.note.id, dst_id: L.dst_id, rationale: L.rationale, provenance: L.provenance, dry_run: $("#dryRun").checked})});
  }
  pendingLinks.length = 0;
  if(saveAndSuggest){
    const sug = await fetch("/api/links/suggest",{method:"POST", headers:{"Content-Type":"application/json"}, body: JSON.stringify({id: js.note.id, title: js.note.title, content: js.note.content})}).then(r=>r.json());
    const items = (sug.suggestions||[]).map(x=>`${x.title} — ${x.rationale} (${Math.round(x.confidence*100)}%)`).join("\\n");
    toast(items ? ("Suggestions:\\n"+items) : "No suggestions.");
  }
}
$("#save").addEventListener("click", ()=>saveNote(false));
$("#saveSuggest").addEventListener("click", ()=>saveNote(true));
document.addEventListener("keydown",(e)=>{
  if((e.metaKey||e.ctrlKey) && e.key.toLowerCase()==="s"){ e.preventDefault(); saveNote(false); }
  if((e.metaKey||e.ctrlKey) && e.key==="Enter"){ e.preventDefault(); saveNote(true); }
});
function toast(msg){ $("#out").innerText = msg; }
</script>
</body>
</html>
"""

@app.get("/")
def home():
    return render_template_string(PAGE)

@app.get("/__graph_hint")
def graph_hint():
    return """<p>Run <code>python graph_app.py</code></p><p>Then open: <a href="http://127.0.0.1:8050" target="_blank">http://127.0.0.1:8050</a></p>"""

if __name__ == "__main__":
    app.run(host="127.0.0.1", port=5000, debug=bool(int(os.getenv("DEBUG","1"))))
```

---

### 2) `graph_app.py` — Dash + Cytoscape (degree sizing + 1-hop highlight)

```python
# graph_app.py
# Run:  python graph_app.py
import json, os, pathlib, time
from dash import Dash, html, dcc, Input, Output, callback_context
import dash_cytoscape as cyto

DATA_DIR = pathlib.Path(os.getenv("DATA_DIR", "./data")).resolve()
GRAPH_PATH = DATA_DIR / "graph" / "graph.json"

app = Dash(__name__)
app.title = "NotaLink Graph"

def load_graph():
    if GRAPH_PATH.exists():
        try:
            js = json.loads(GRAPH_PATH.read_text(encoding="utf-8"))
            nodes = js.get("nodes",[])
            edges = js.get("edges",[])
        except Exception:
            nodes, edges = [], []
    else:
        nodes, edges = [], []
    # Cytoscape wants a single elements list
    elements = []
    for n in nodes:
        data = n["data"]; size = data.get("size", 20)
        elements.append({"data": data, "classes": ""})
    for e in edges:
        elements.append({"data": e["data"]})
    return elements

app.layout = html.Div([
    html.H2("NotaLink – Graph View"),
    html.Div("Degree-based node sizing • Click a node to 1-hop highlight"),
    dcc.Interval(id="tick", interval=3000, n_intervals=0),
    cyto.Cytoscape(
        id='graph',
        layout={'name': 'cose', 'animate': False},
        style={'width': '100%', 'height': '76vh', 'border':'1px solid #e2e8f0'},
        elements=load_graph(),
        stylesheet=[
            {'selector':'node','style':{
                'label':'data(label)',
                'width':'data(size)','height':'data(size)',
                'background-color':'#60a5fa',
                'color':'#0f172a','font-size':'10px','text-wrap':'wrap','text-max-width':120,
                'border-width':1,'border-color':'#1e3a8a'
            }},
            {'selector':'edge','style':{'line-color':'#94a3b8','width':2}},
            {'selector':'.faded','style':{'opacity':0.15}},
            {'selector':'.neighbor','style':{'background-color':'#22c55e','border-color':'#166534'}},
            {'selector':'.focus','style':{'background-color':'#ef4444','border-color':'#991b1b','width': 'mapData(degree, 0, 20, 30, 80)', 'height':'mapData(degree, 0, 20, 30, 80)'}}
        ],
    ),
    html.Div(id="status", style={"marginTop":"8px","color":"#475569"})
])

@app.callback(
    Output('graph','elements'),
    Input('tick','n_intervals')
)
def refresh(n):
    return load_graph()

@app.callback(
    Output('status','children'),
    Input('graph','tapNode')
)
def one_hop_highlight(node):
    # Set classes client-side via data payload; simple instruction text here
    if not node: return "Tip: Click a node to highlight 1-hop neighbors."
    return f"Focused: {node['data'].get('label','')} (degree {node['data'].get('degree',0)})"

# Clientside callback to apply classes for 1-hop highlight
app.clientside_callback(
    """
    function(nodeData, elements){
      if(!nodeData || !elements){ return elements; }
      const focusId = nodeData.data.id;
      const neighbors = new Set([focusId]);
      // Collect neighbors
      elements.forEach(el=>{
        if(el.data && el.data.source && el.data.target){
          if(el.data.source===focusId) neighbors.add(el.data.target);
          if(el.data.target===focusId) neighbors.add(el.data.source);
        }
      });
      // Apply classes
      elements.forEach(el=>{
        el.classes = "";
        if(el.data && el.data.id===focusId){ el.classes = "focus"; }
        if(el.data && !el.data.source){ // node
          if(neighbors.has(el.data.id)){ el.classes += (el.classes?" ":"") + "neighbor"; }
          else { el.classes += (el.classes?" ":"") + "faded"; }
        }
        if(el.data && el.data.source){ // edge
          if(el.data.source===focusId || el.data.target===focusId) { /* keep */ }
          else { el.classes = "faded"; }
        }
      });
      return elements;
    }
    """,
    Output('graph','elements'),
    Input('graph','tapNode'),
    Input('graph','elements')
)

if __name__ == "__main__":
    app.run(host="127.0.0.1", port=8050, debug=True)
```

---

### 3) NOTES.md — where things go & why (and safe-info tips for the internal LLM)

```md
# NotaLink MVP (Add Note 2.0 + Graph + Quip) – Setup & Rationale

## Files
- `app.py` — Flask UI for Add Note 2.0 (inline HTML/JS); REST for:
  - `POST /api/notes` (atomic write → `data/notes/{id}.json`, rebuild index, compute graph)
  - `POST /api/links/create` (atomic write → `data/links/{id}.json`, recompute graph)
  - `POST /api/links/suggest` (naive lexical overlap; extend later w/ LLM)
  - `GET /api/quip/search` (real if `QUIP_TOKEN` set; else mock)
  - `GET /api/quip/thread_html` (paged HTML; mock-aware)
  - `GET /api/quip/folder` (browse; mock-aware)
  - `POST /api/quip/summarize` (placeholder summarizer; swap with internal LLM)
- `graph_app.py` — Dash + Cytoscape graph reading `data/graph/graph.json`, with
  - Degree-based node sizing
  - 1-hop highlight on click (client-side class toggling)

## Data layout (filesystem-first)
```

data/
notes/           # {id}.json
links/           # {id}.json
index/           # inverted.jsonl
graph/           # graph.json
lookup\_cache/    # quip search cache
\_wal/            # write-ahead log entries

````

## Run
```bash
# 1) UI for Add Note 2.0
export DATA_DIR=./data
# optional: export QUIP_TOKEN=...  # to enable real Quip calls
python app.py

# 2) Graph view
python graph_app.py
# open http://127.0.0.1:8050
````

## Why this shape?

* **Atomic writes + WAL** — durability + rollback surface.
* **Inline HTML/JS** — minimal moving parts; easy to lift into templates later.
* **Mock-aware Quip client** — end-to-end flows work even without credentials.
* **LLM-ready ports** — `/api/quip/summarize` is the swap point to call your internal LLM.

## Securely giving me info (internal LLM + Quip)

* **Never paste tokens** into chat. Put them in `.env` / environment (`QUIP_TOKEN`) locally.
* **Minimize data exposure**: test with non-sensitive Quip docs or mocks first.
* **Redact** PII/confidential text before sharing example payloads with me.
* **Principle of least data**: if you need me to reason about structure, send **schemas** and **fake records** only.
* **Use provenance**: keep `citations[]` and `provenance[]` (quip\://…) so nothing is re-shared from memory.

```

---

That’s the full minimal build you asked for. Next logical step (when you’re ready): wire `/api/quip/summarize` to your internal LLM and, if desired, split the inline HTML into Jinja templates + add the Link Review table UI.
```
